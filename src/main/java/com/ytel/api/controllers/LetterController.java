/*
 * YtelAPIV3Lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
package com.ytel.api.controllers;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;

import com.ytel.api.*;
import com.ytel.api.models.*;
import com.ytel.api.exceptions.*;
import com.ytel.api.http.client.HttpClient;
import com.ytel.api.http.client.HttpContext;
import com.ytel.api.http.request.HttpRequest;
import com.ytel.api.http.response.HttpResponse;
import com.ytel.api.http.response.HttpStringResponse;
import com.ytel.api.http.client.APICallBack;
import com.ytel.api.controllers.syncwrapper.APICallBackCatcher;

public class LetterController extends BaseController {    
    //private static variables for the singleton pattern
    private static Object syncObject = new Object();
    private static LetterController instance = null;

    /**
     * Singleton pattern implementation 
     * @return The singleton instance of the LetterController class 
     */
    public static LetterController getInstance() {
        synchronized (syncObject) {
            if (null == instance) {
                instance = new LetterController();
            }
        }
        return instance;
    }

    /**
     * Remove a letter object by its LetterId.
     * @param    lettersid    Required parameter: The unique identifier for a letter object.
     * @return    Returns the String response from the API call 
     */
    public String createDeleteLetter(
                final String lettersid
    ) throws Throwable {
        APICallBackCatcher<String> callback = new APICallBackCatcher<String>();
        createDeleteLetterAsync(lettersid, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Remove a letter object by its LetterId.
     * @param    lettersid    Required parameter: The unique identifier for a letter object.
     * @return    Returns the void response from the API call 
     */
    public void createDeleteLetterAsync(
                final String lettersid,
                final APICallBack<String> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {
                //the base uri for api requests
                String _baseUri = Configuration.baseUri;

                //prepare query string for API call
                StringBuilder _queryBuilder = new StringBuilder(_baseUri);
                _queryBuilder.append("/letter/delete.json");
                //validate and preprocess url
                String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

                //load all headers for the outgoing API request
                Map<String, String> _headers = new HashMap<String, String>() {
                    private static final long serialVersionUID = 9024873901054908219L;
                    {
                        put( "user-agent", "APIMATIC 2.0" );
                    }
                };

                //load all fields for the outgoing API request
                Map<String, Object> _parameters = new HashMap<String, Object>() {
                    private static final long serialVersionUID = -3673784710767681992L;
                    {
                        put( "lettersid", lettersid );
                    }
                };

                //prepare and invoke the API call request to fetch the response
                final HttpRequest _request = getClientInstance().post(_queryUrl, _headers, APIHelper.prepareFormFields(_parameters),
                                                Configuration.basicAuthUserName, Configuration.basicAuthPassword);

                //invoke the callback before request if its not null
                if (getHttpCallBack() != null)
                {
                    getHttpCallBack().OnBeforeRequest(_request);
                }

                //invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _result = ((HttpStringResponse)_response).getBody();
                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)
                        {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieve a letter object by its LetterSid.
     * @param    lettersid    Required parameter: The unique identifier for a letter object.
     * @return    Returns the String response from the API call 
     */
    public String createViewLetter(
                final String lettersid
    ) throws Throwable {
        APICallBackCatcher<String> callback = new APICallBackCatcher<String>();
        createViewLetterAsync(lettersid, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Retrieve a letter object by its LetterSid.
     * @param    lettersid    Required parameter: The unique identifier for a letter object.
     * @return    Returns the void response from the API call 
     */
    public void createViewLetterAsync(
                final String lettersid,
                final APICallBack<String> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {
                //the base uri for api requests
                String _baseUri = Configuration.baseUri;

                //prepare query string for API call
                StringBuilder _queryBuilder = new StringBuilder(_baseUri);
                _queryBuilder.append("/letter/viewletter.json");
                //validate and preprocess url
                String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

                //load all headers for the outgoing API request
                Map<String, String> _headers = new HashMap<String, String>() {
                    private static final long serialVersionUID = 9024873901054908219L;
                    {
                        put( "user-agent", "APIMATIC 2.0" );
                    }
                };

                //load all fields for the outgoing API request
                Map<String, Object> _parameters = new HashMap<String, Object>() {
                    private static final long serialVersionUID = -3673784710767681992L;
                    {
                        put( "lettersid", lettersid );
                    }
                };

                //prepare and invoke the API call request to fetch the response
                final HttpRequest _request = getClientInstance().post(_queryUrl, _headers, APIHelper.prepareFormFields(_parameters),
                                                Configuration.basicAuthUserName, Configuration.basicAuthPassword);

                //invoke the callback before request if its not null
                if (getHttpCallBack() != null)
                {
                    getHttpCallBack().OnBeforeRequest(_request);
                }

                //invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _result = ((HttpStringResponse)_response).getBody();
                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)
                        {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Create, print, and mail a letter to an address. The letter file must be supplied as a PDF or an HTML string.
     * @param    to    Required parameter: The AddressId or an object structured when creating an address by addresses/Create.
     * @param    from    Required parameter: The AddressId or an object structured when creating an address by addresses/Create.
     * @param    attachbyid    Required parameter: Set an existing letter by attaching its LetterId.
     * @param    file    Required parameter: File can be a 8.5"x11" PDF uploaded file or URL that links to a file.
     * @param    color    Required parameter: Specify if letter should be printed in color.
     * @param    description    Optional parameter: A description for the letter.
     * @param    extraservice    Optional parameter: Add an extra service to your letter. Options are "certified" or "registered". Certified provides tracking and delivery confirmation for domestic destinations and is an additional $5.00. Registered provides tracking and confirmation for international addresses and is an additional $16.50.
     * @param    doublesided    Optional parameter: Specify if letter should be printed on both sides.
     * @param    template    Optional parameter: Boolean that defaults to true. When set to false, this specifies that your letter does not follow the m360 address template. In this case, a blank address page will be inserted at the beginning of your file and you will be charged for the extra page.
     * @param    htmldata    Optional parameter: A string value that contains HTML markup.
     * @return    Returns the String response from the API call 
     */
    public String createLetter(
                final String to,
                final String from,
                final String attachbyid,
                final String file,
                final String color,
                final String description,
                final String extraservice,
                final String doublesided,
                final String template,
                final String htmldata
    ) throws Throwable {
        APICallBackCatcher<String> callback = new APICallBackCatcher<String>();
        createLetterAsync(to, from, attachbyid, file, color, description, extraservice, doublesided, template, htmldata, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Create, print, and mail a letter to an address. The letter file must be supplied as a PDF or an HTML string.
     * @param    to    Required parameter: The AddressId or an object structured when creating an address by addresses/Create.
     * @param    from    Required parameter: The AddressId or an object structured when creating an address by addresses/Create.
     * @param    attachbyid    Required parameter: Set an existing letter by attaching its LetterId.
     * @param    file    Required parameter: File can be a 8.5"x11" PDF uploaded file or URL that links to a file.
     * @param    color    Required parameter: Specify if letter should be printed in color.
     * @param    description    Optional parameter: A description for the letter.
     * @param    extraservice    Optional parameter: Add an extra service to your letter. Options are "certified" or "registered". Certified provides tracking and delivery confirmation for domestic destinations and is an additional $5.00. Registered provides tracking and confirmation for international addresses and is an additional $16.50.
     * @param    doublesided    Optional parameter: Specify if letter should be printed on both sides.
     * @param    template    Optional parameter: Boolean that defaults to true. When set to false, this specifies that your letter does not follow the m360 address template. In this case, a blank address page will be inserted at the beginning of your file and you will be charged for the extra page.
     * @param    htmldata    Optional parameter: A string value that contains HTML markup.
     * @return    Returns the void response from the API call 
     */
    public void createLetterAsync(
                final String to,
                final String from,
                final String attachbyid,
                final String file,
                final String color,
                final String description,
                final String extraservice,
                final String doublesided,
                final String template,
                final String htmldata,
                final APICallBack<String> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {
                //the base uri for api requests
                String _baseUri = Configuration.baseUri;

                //prepare query string for API call
                StringBuilder _queryBuilder = new StringBuilder(_baseUri);
                _queryBuilder.append("/letter/create.json");
                //validate and preprocess url
                String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

                //load all headers for the outgoing API request
                Map<String, String> _headers = new HashMap<String, String>() {
                    private static final long serialVersionUID = 9024873901054908219L;
                    {
                        put( "user-agent", "APIMATIC 2.0" );
                    }
                };

                //load all fields for the outgoing API request
                Map<String, Object> _parameters = new HashMap<String, Object>() {
                    private static final long serialVersionUID = -17076590L;
                    {
                        put( "to", to );
                        put( "from", from );
                        put( "attachbyid", attachbyid );
                        put( "file", file );
                        put( "color", color );
                        put( "description", description );
                        put( "extraservice", extraservice );
                        put( "doublesided", doublesided );
                        put( "template", template );
                        put( "htmldata", htmldata );
                    }
                };

                //prepare and invoke the API call request to fetch the response
                final HttpRequest _request = getClientInstance().post(_queryUrl, _headers, APIHelper.prepareFormFields(_parameters),
                                                Configuration.basicAuthUserName, Configuration.basicAuthPassword);

                //invoke the callback before request if its not null
                if (getHttpCallBack() != null)
                {
                    getHttpCallBack().OnBeforeRequest(_request);
                }

                //invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _result = ((HttpStringResponse)_response).getBody();
                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)
                        {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieve a list of letter objects. The letter objects are sorted by creation date, with the most recently created letters appearing first.
     * @param    page    Optional parameter: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
     * @param    pagesize    Optional parameter: The count of objects to return per page.
     * @param    lettersid    Optional parameter: The unique identifier for a letter object.
     * @param    dateCreated    Optional parameter: The date the letter was created.
     * @return    Returns the String response from the API call 
     */
    public String createListLetters(
                final Integer page,
                final Integer pagesize,
                final String lettersid,
                final String dateCreated
    ) throws Throwable {
        APICallBackCatcher<String> callback = new APICallBackCatcher<String>();
        createListLettersAsync(page, pagesize, lettersid, dateCreated, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Retrieve a list of letter objects. The letter objects are sorted by creation date, with the most recently created letters appearing first.
     * @param    page    Optional parameter: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
     * @param    pagesize    Optional parameter: The count of objects to return per page.
     * @param    lettersid    Optional parameter: The unique identifier for a letter object.
     * @param    dateCreated    Optional parameter: The date the letter was created.
     * @return    Returns the void response from the API call 
     */
    public void createListLettersAsync(
                final Integer page,
                final Integer pagesize,
                final String lettersid,
                final String dateCreated,
                final APICallBack<String> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {
                //the base uri for api requests
                String _baseUri = Configuration.baseUri;

                //prepare query string for API call
                StringBuilder _queryBuilder = new StringBuilder(_baseUri);
                _queryBuilder.append("/letter/listsletter.json");
                //validate and preprocess url
                String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

                //load all headers for the outgoing API request
                Map<String, String> _headers = new HashMap<String, String>() {
                    private static final long serialVersionUID = 9024873901054908219L;
                    {
                        put( "user-agent", "APIMATIC 2.0" );
                    }
                };

                //load all fields for the outgoing API request
                Map<String, Object> _parameters = new HashMap<String, Object>() {
                    private static final long serialVersionUID = -863719911L;
                    {
                        put( "page", page );
                        put( "pagesize", pagesize );
                        put( "lettersid", lettersid );
                        put( "dateCreated", dateCreated );
                    }
                };

                //prepare and invoke the API call request to fetch the response
                final HttpRequest _request = getClientInstance().post(_queryUrl, _headers, APIHelper.prepareFormFields(_parameters),
                                                Configuration.basicAuthUserName, Configuration.basicAuthPassword);

                //invoke the callback before request if its not null
                if (getHttpCallBack() != null)
                {
                    getHttpCallBack().OnBeforeRequest(_request);
                }

                //invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _result = ((HttpStringResponse)_response).getBody();
                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)
                        {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

}